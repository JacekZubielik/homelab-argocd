# helm repo add jetstack https://charts.jetstack.io
# helm show values jetstack/cert-manager >> cert-manager-values.yaml

#################################

global:
  imagePullSecrets: []
  commonLabels: {}
  priorityClassName: ""
  rbac:
    create: true
    aggregateClusterRoles: true

  podSecurityPolicy:
    enabled: false
    useAppArmor: true

  logLevel: 2
  leaderElection:
    namespace: cert-manager #"kube-system"

#################################

fullnameOverride: cert-manager
installCRDs: true
replicaCount: 1
strategy:
  type: RollingUpdate
  # rollingUpdate:
  #   maxSurge: 0
  #   maxUnavailable: 1

podDisruptionBudget:
  enabled: true
  # minAvailable: 1
  # maxUnavailable: 1

featureGates: ""
maxConcurrentChallenges: 60

image:
  repository: quay.io/jetstack/cert-manager-controller
  pullPolicy: IfNotPresent
clusterResourceNamespace: ""

namespace: ""

#################################

serviceAccount:
  create: true
  # annotations:
  #   helm.sh/hook: post-install
  #   helm.sh/hook-weight: "-5"
  #   helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded
  #   eks.amazonaws.com/role-arn: arn:aws:iam::227651627371:role/cert-manager
  automountServiceAccountToken: false

#################################

enableCertificateOwnerRef: true

#config:

dns01RecursiveNameservers: "1.1.1.1:53,1.0.0.1:53"
dns01RecursiveNameserversOnly: false
podDnsPolicy: None
podDnsConfig:
  nameservers:
    - 1.1.1.1
    - 1.0.0.1
    # - 9.9.9.9

extraArgs: []
extraEnv: []
resources: {}
  # requests:
  #   cpu: 10m
  #   memory: 32Mi

securityContext:
  #fsGroup: 1001
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

containerSecurityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true

volumes: []
volumeMounts: []
podLabels: {}

# Optional DNS settings, useful if you have a public and private DNS zone for
# the same domain on Route 53. What follows is an example of ensuring
# cert-manager can access an ingress or DNS TXT records at all times.
# NOTE: This requires Kubernetes 1.10 or `CustomPodDNS` feature gate enabled for
# the cluster to work.
# podDnsPolicy: "None"
# podDnsConfig:
#   nameservers:
#     - "1.1.1.1"
#     - "8.8.8.8"

nodeSelector:
  kubernetes.io/os: linux

#################################

prometheus:
  enabled: false
  servicemonitor:
    enabled: false
    labels:
      release: monitoring
    prometheusInstance: default
    targetPort: 9402
    path: /metrics
    interval: 60s
    scrapeTimeout: 30s
    labels: {}
    annotations: {}
    honorLabels: false
    endpointAdditionalProperties: {}

affinity: {}
tolerations: []
topologySpreadConstraints: []

livenessProbe:
  enabled: false
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 15
  successThreshold: 1
  failureThreshold: 8

enableServiceLinks: false

#################################

webhook:
  replicaCount: 1
  timeoutSeconds: 10
  config:
  strategy:
    type: RollingUpdate
    rollingUpdate: {}

  securityContext:
    #fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  podDisruptionBudget:
    enabled: true

  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true

  extraArgs: []
  featureGates: ""
  resources: {}
    # requests:
    #   cpu: 10m
    #   memory: 32Mi

  livenessProbe:
    failureThreshold: 3
    initialDelaySeconds: 60
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1
  readinessProbe:
    failureThreshold: 3
    initialDelaySeconds: 5
    periodSeconds: 5
    successThreshold: 1
    timeoutSeconds: 1

  nodeSelector:
    kubernetes.io/os: linux

  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  podLabels: {}
  serviceLabels: {}

  image:
    repository: quay.io/jetstack/cert-manager-webhook
    pullPolicy: IfNotPresent

  serviceAccount:
    create: true
    automountServiceAccountToken: false
    # annotations:
    #   helm.sh/hook: post-install
    #   helm.sh/hook-weight: "-5"
    #   helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded

  securePort: 10250
  hostNetwork: false
  serviceType: ClusterIP

  url: {}
    # host:

  networkPolicy:
    enabled: false
    ingress:
    - from:
      - ipBlock:
          cidr: 0.0.0.0/0
    egress:
    - ports:
      - port: 80
        protocol: TCP
      - port: 443
        protocol: TCP
      - port: 53
        protocol: TCP
      - port: 53
        protocol: UDP
      # On OpenShift and OKD, the Kubernetes API server listens on
      # port 6443.
      - port: 6443
        protocol: TCP
      to:
      - ipBlock:
          cidr: 0.0.0.0/0

  volumes: []
  volumeMounts: []

  enableServiceLinks: false

#################################

cainjector:
  enabled: true
  replicaCount: 1

  strategy:
    type: RollingUpdate
    rollingUpdate:
    #   maxSurge: 0
    #   maxUnavailable: 1

  securityContext:
    #fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  podDisruptionBudget:
    enabled: true

  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true

  extraArgs: []
  resources: {}
    # requests:
    #   cpu: 10m
    #   memory: 32Mi

  nodeSelector:
    kubernetes.io/os: linux

  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  podLabels: {}

  image:
    repository: quay.io/jetstack/cert-manager-cainjector
    pullPolicy: IfNotPresent

  serviceAccount:
    create: true
    automountServiceAccountToken: false

  volumes: []
  volumeMounts: []
  enableServiceLinks: false

#################################

acmesolver:
  image:
    repository: quay.io/jetstack/cert-manager-acmesolver

#################################

startupapicheck:
  enabled: true
  securityContext:
    #fsGroup: 1001
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
  timeout: 5m
  backoffLimit: 4

  # jobAnnotations:
  #   helm.sh/hook: post-install
  #   helm.sh/hook-weight: "1"
  #   helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded

  extraArgs: []
  resources: {}
    # requests:
    #   cpu: 10m
    #   memory: 32Mi

  nodeSelector:
    kubernetes.io/os: linux

  affinity: {}
  tolerations: []
  podLabels: {}

  image:
    repository: quay.io/jetstack/cert-manager-ctl
    pullPolicy: IfNotPresent

  # rbac:
  #   annotations:
  #     helm.sh/hook: post-install
  #     helm.sh/hook-weight: "-5"
  #     helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded

  serviceAccount:
    create: true

    # annotations:
    #   helm.sh/hook: post-install
    #   helm.sh/hook-weight: "-5"
    #   helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded

    automountServiceAccountToken: false

  volumes: []
  volumeMounts: []

  enableServiceLinks: false

