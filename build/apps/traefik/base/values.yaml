# helm repo add traefik https://helm.traefik.io/traefik
#
# helm show values traefik/traefik  >> traefik-values.yaml

deployment:
  enabled: true
  kind: Deployment
  replicas: 1
  terminationGracePeriodSeconds: 60
  minReadySeconds: 0
  annotations: {}
  labels: {}
  podAnnotations: {}
  podLabels: {}
  additionalContainers: []
  additionalVolumes:
  - name: plugins
  - name: traefik-logs
  initContainers:
    - name: data-accesslog
      image: busybox:latest
      args:
        - /bin/sh
        - -c
        - tail -n+1 -F /data/access.log
      imagePullPolicy: Always
      resources: {}
      terminationMessagePath: /dev/termination-log
      terminationMessagePolicy: File
      volumeMounts:
      - name: data
        mountPath: /data
  shareProcessNamespace: false
  dnsConfig: {}
  imagePullSecrets: []
  lifecycle: {}

# -- Pod disruption budget
podDisruptionBudget:
  enabled: false
  # maxUnavailable: 1
  # maxUnavailable: 33%
  # minAvailable: 0
  # minAvailable: 25%

# -- Create a default IngressClass for Traefik
ingressClass:
  enabled: true
  isDefaultClass: false
  # name: my-custom-class

experimental:
  http3:
    enabled: true
  plugins:
    enabled: false
    # fail2ban:
    #   moduleName: "github.com/tomMoulard/fail2ban"
    #   version: "v0.7.1"
  kubernetesGateway:
    # -- Enable traefik experimental GatewayClass CRD
    enabled: false


## Create an IngressRoute for the dashboard
ingressRoute:
  dashboard:
    enabled: true
    annotations: {}
    labels: {}
    matchRule: PathPrefix(`/dashboard`) || PathPrefix(`/api`)
    entryPoints: ["traefik"]
    middlewares: []
    tls: {}
  healthcheck:
    enabled: false
    annotations: {}
    labels: {}
    matchRule: PathPrefix(`/ping`)
    entryPoints: ["traefik"]
    middlewares: []
    tls: {}

updateStrategy:
  # -- Customize updateStrategy: RollingUpdate or OnDelete
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 0
    maxSurge: 1

readinessProbe:
  failureThreshold: 1
  initialDelaySeconds: 2
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 2
livenessProbe:
  failureThreshold: 3
  initialDelaySeconds: 2
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 2

#startupProbe:

providers:
  kubernetesCRD:
    enabled: true
    allowCrossNamespace: true
    allowExternalNameServices: true
    allowEmptyServices: true # 
    ingressClass: traefik-internal
    # labelSelector: environment=production,method=traefik
    labelSelector: "app=traefik" # -- Array of namespaces to watch. If left empty, Traefik watches all namespaces.

    namespaces: []
    # - "default"

  kubernetesIngress:
    enabled: true
    allowExternalNameServices: true
    allowEmptyServices: true
    namespaces: []
    # - "default"
    publishedService:
      enabled: true


  file:
    # -- Create a file provider
    enabled: false
    watch: true
    content: ""

volumes: []
# - name: public-cert
#   mountPath: "/certs"
#   type: secret
# - name: '{{ printf "%s-configs" .Release.Name }}'
#   mountPath: "/config"
#   type: configMap

# -- Additional volumeMounts to add to the Traefik container
additionalVolumeMounts:
- name: plugins
  mountPath: /plugins-storage
- name: traefik-logs
  mountPath: /var/log/traefik



logs:
  general:
    # -- Alternative logging levels are DEBUG, PANIC, FATAL, ERROR, WARN, and INFO.
    level: ERROR

  access:
    enabled: true
    format: json
    filters: {}
    fields:
      general:
        defaultmode: keep
        names: {}
      headers:
        defaultmode: drop
        names: {}



metrics:
  prometheus:
    addEntryPointsLabels: true
    addRoutersLabels: true
    addServicesLabels: true
    entryPoint: metrics
    buckets: "0.5,1.0,5"
  #  datadog:
  #    ## Address instructs exporter to send metrics to datadog-agent at this address.
  #    address: "127.0.0.1:8125"
  #    ## The interval used by the exporter to push metrics to datadog-agent. Default=10s
  #    # pushInterval: 30s
  #    ## The prefix to use for metrics collection. Default="traefik"
  #    # prefix: traefik
  #    ## Enable metrics on entry points. Default=true
  #    # addEntryPointsLabels: false
  #    ## Enable metrics on routers. Default=false
  #    # addRoutersLabels: true
  #    ## Enable metrics on services. Default=true
  #    # addServicesLabels: false
  #  influxdb:
  #    ## Address instructs exporter to send metrics to influxdb at this address.
  #    address: localhost:8089
  #    ## InfluxDB's address protocol (udp or http). Default="udp"
  #    protocol: udp
  #    ## InfluxDB database used when protocol is http. Default=""
  #    # database: ""
  #    ## InfluxDB retention policy used when protocol is http. Default=""
  #    # retentionPolicy: ""
  #    ## InfluxDB username (only with http). Default=""
  #    # username: ""
  #    ## InfluxDB password (only with http). Default=""
  #    # password: ""
  #    ## The interval used by the exporter to push metrics to influxdb. Default=10s
  #    # pushInterval: 30s
  #    ## Additional labels (influxdb tags) on all metrics.
  #    # additionalLabels:
  #    #   env: production
  #    #   foo: bar
  #    ## Enable metrics on entry points. Default=true
  #    # addEntryPointsLabels: false
  #    ## Enable metrics on routers. Default=false
  #    # addRoutersLabels: true
  #    ## Enable metrics on services. Default=true
  #    # addServicesLabels: false
  #  influxdb2:
  #    ## Address instructs exporter to send metrics to influxdb v2 at this address.
  #    address: localhost:8086
  #    ## Token with which to connect to InfluxDB v2.
  #    token: xxx
  #    ## Organisation where metrics will be stored.
  #    org: ""
  #    ## Bucket where metrics will be stored.
  #    bucket: ""
  #    ## The interval used by the exporter to push metrics to influxdb. Default=10s
  #    # pushInterval: 30s
  #    ## Additional labels (influxdb tags) on all metrics.
  #    # additionalLabels:
  #    #   env: production
  #    #   foo: bar
  #    ## Enable metrics on entry points. Default=true
  #    # addEntryPointsLabels: false
  #    ## Enable metrics on routers. Default=false
  #    # addRoutersLabels: true
  #    ## Enable metrics on services. Default=true
  #    # addServicesLabels: false
  #  statsd:
  #    ## Address instructs exporter to send metrics to statsd at this address.
  #    address: localhost:8125
  #    ## The interval used by the exporter to push metrics to influxdb. Default=10s
  #    # pushInterval: 30s
  #    ## The prefix to use for metrics collection. Default="traefik"
  #    # prefix: traefik
  #    ## Enable metrics on entry points. Default=true
  #    # addEntryPointsLabels: false
  #    ## Enable metrics on routers. Default=false
  #    # addRoutersLabels: true
  #    ## Enable metrics on services. Default=true
  #    # addServicesLabels: false
  #  openTelemetry:
  #    ## Address of the OpenTelemetry Collector to send metrics to.
  #    address: "localhost:4318"
  #    ## Enable metrics on entry points.
  #    addEntryPointsLabels: true
  #    ## Enable metrics on routers.
  #    addRoutersLabels: true
  #    ## Enable metrics on services.
  #    addServicesLabels: true
  #    ## Explicit boundaries for Histogram data points.
  #    explicitBoundaries:
  #      - "0.1"
  #      - "0.3"
  #      - "1.2"
  #      - "5.0"
  #    ## Additional headers sent with metrics by the reporter to the OpenTelemetry Collector.
  #    headers:
  #      foo: bar
  #      test: test
  #    ## Allows reporter to send metrics to the OpenTelemetry Collector without using a secured protocol.
  #    insecure: true
  #    ## Interval at which metrics are sent to the OpenTelemetry Collector.
  #    pushInterval: 10s
  #    ## Allows to override the default URL path used for sending metrics. This option has no effect when using gRPC transport.
  #    path: /foo/v1/traces
  #    ## Defines the TLS configuration used by the reporter to send metrics to the OpenTelemetry Collector.
  #    tls:
  #      ## The path to the certificate authority, it defaults to the system bundle.
  #      ca: path/to/ca.crt
  #      ## The path to the public certificate. When using this option, setting the key option is required.
  #      cert: path/to/foo.cert
  #      ## The path to the private key. When using this option, setting the cert option is required.
  #      key: path/to/key.key
  #      ## If set to true, the TLS connection accepts any certificate presented by the server regardless of the hostnames it covers.
  #      insecureSkipVerify: true
  #    ## This instructs the reporter to send metrics to the OpenTelemetry Collector using gRPC.
  #    grpc: true

  ## -- enable optional CRDs for Prometheus Operator
  ##
  ## Create a dedicated metrics service for use with ServiceMonitor
  #  service:
  #    enabled: false
  #    labels: {}
  #    annotations: {}
  ## When set to true, it won't check if Prometheus Operator CRDs are deployed
  #  disableAPICheck: false
  #  serviceMonitor:
  #    metricRelabelings: []
  #      - sourceLabels: [__name__]
  #        separator: ;
  #        regex: ^fluentd_output_status_buffer_(oldest|newest)_.+
  #        replacement: $1
  #        action: drop
  #    relabelings: []
  #      - sourceLabels: [__meta_kubernetes_pod_node_name]
  #        separator: ;
  #        regex: ^(.*)$
  #        targetLabel: nodename
  #        replacement: $1
  #        action: replace
  #    jobLabel: traefik
  #    interval: 30s
  #    honorLabels: true
  #    # (Optional)
  #    # scrapeTimeout: 5s
  #    # honorTimestamps: true
  #    # enableHttp2: true
  #    # followRedirects: true
  #    # additionalLabels:
  #    #   foo: bar
  #    # namespace: "another-namespace"
  #    # namespaceSelector: {}
  #  prometheusRule:
  #    additionalLabels: {}
  #    namespace: "another-namespace"
  #    rules:
  #      - alert: TraefikDown
  #        expr: up{job="traefik"} == 0
  #        for: 5m
  #        labels:
  #          context: traefik
  #          severity: warning
  #        annotations:
  #          summary: "Traefik Down"
  #          description: "{{ $labels.pod }} on {{ $labels.nodename }} is down"

## Tracing
# -- https://doc.traefik.io/traefik/observability/tracing/overview/
tracing:
  serviceName: traefik
#  openTelemetry: # traefik v3+ only
#    grpc: true
#    insecure: true
#    address: localhost:4317
# instana:
#   localAgentHost: 127.0.0.1
#   localAgentPort: 42699
#   logLevel: info
#   enableAutoProfile: true
# datadog:
#   localAgentHostPort: 127.0.0.1:8126
#   debug: false
#   globalTag: ""
#   prioritySampling: false
# jaeger:
#   samplingServerURL: http://localhost:5778/sampling
#   samplingType: const
#   samplingParam: 1.0
#   localAgentHostPort: 127.0.0.1:6831
#   gen128Bit: false
#   propagation: jaeger
#   traceContextHeaderName: uber-trace-id
#   disableAttemptReconnecting: true
#   collector:
#      endpoint: ""
#      user: ""
#      password: ""
# zipkin:
#   httpEndpoint: http://localhost:9411/api/v2/spans
#   sameSpan: false
#   id128Bit: true
#   sampleRate: 1.0
# haystack:
#   localAgentHost: 127.0.0.1
#   localAgentPort: 35000
#   globalTag: ""
#   traceIDHeaderName: ""
#   parentIDHeaderName: ""
#   spanIDHeaderName: ""
#   baggagePrefixHeaderName: ""
  elastic:
    serverURL: http://localhost:8200
#   secretToken: ""
#   serviceEnvironment: ""

# -- Global command arguments to be passed to all traefik's pods
globalArguments:
- "--global.checknewversion=false"
- "--global.sendanonymoususage=false"

# All available options available on https://docs.traefik.io/reference/static-configuration/cli/
## Use curly braces to pass values: `helm install --set="additionalArguments={--providers.kubernetesingress.ingressclass=traefik-internal,--log.level=DEBUG}"`
additionalArguments:
- "--log.level=DEBUG"
# - "--log.level=INFO"
- "--api.dashboard=true"
- "--api.insecure=true"
- "--accesslog.filepath=/data/access.log"
- "--providers.kubernetesingress.ingressendpoint.publishedservice=traefik/traefik"
- "--providers.kubernetesingress.ingressclass=traefik-internal"
- "--entrypoints.websecure.http.tls=true"
- "--serversTransport.insecureSkipVerify=true"

  #
  # Shouldn't need this if you've got Cert Manager installed
  #
  #- "--certificatesresolvers.letsencrypt.acme.tlschallenge=true"
  #- "--certificatesresolvers.letsencrypt.acme.email=<FIXME>"
  #- "--certificatesresolvers.letsencrypt.acme.storage=/data/acme.json"
  #- "--certificatesresolvers.letsencrypt-staging.acme.tlschallenge=true"
  #- "--certificatesresolvers.letsencrypt-staging.acme.email=<FIXME>"
  #- "--certificatesresolvers.letsencrypt-staging.acme.storage=/data/acme.json"
  #- "--certificatesresolvers.letsencrypt-staging.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory"



# -- Environment variables to be passed to Traefik's binary
env: []
# - name: POD_NAME
#   valueFrom:
#     fieldRef:
#       fieldPath: metadata.name
# - name: POD_NAMESPACE
#   valueFrom:
#     fieldRef:
#       fieldPath: metadata.namespace
# - name: SOME_VAR
#   value: some-var-value
# - name: SOME_VAR_FROM_CONFIG_MAP
#   valueFrom:
#     configMapRef:
#       name: configmap-name
#       key: config-key
# - name: SOME_SECRET
#   valueFrom:
#     secretKeyRef:
#       name: secret-name
#       key: secret-key

# -- Environment variables to be passed to Traefik's binary from configMaps or secrets
envFrom: []
# - configMapRef:
#     name: config-map-name
# - secretRef:
#     name: secret-name

ports:
  ping:
    port: 8081
  traefik:
    port: 9000
    expose: true
    exposedPort: 9000
    protocol: TCP
  web:
    redirectTo:
        port: websecure
    port: 80 #80 #8000
    expose: true
    exposedPort: 80
    protocol: TCP
  websecure:
    port: 443 #443 #8443
    expose: true
    exposedPort: 443
    protocol: TCP
    http3:
      enabled: true
    # advertisedPort: 4443

    tls:
      enabled: true
      certResolver: route53-certificate-anotherlife-pl-staging #-production
      domains:
        - main: 'anotherlife.pl'
          sans:
            - '*.anotherlife.pl'
      # options:
        # default:
        #   cipherSuites:
        #     - TLS_AES_128_GCM_SHA256 uint16 = 0x1301
        #     - TLS_AES_256_GCM_SHA384       uint16 = 0x1302
        #     - TLS_CHACHA20_POLY1305_SHA256 uint16 = 0x1303
        # mintls13:
        #   minVersion: VersionTLS13
    middlewares: []
  metrics:
    port: 9100
    expose: true
    exposedPort: 9100
    protocol: TCP




# -- TLS Options are created as TLSOption CRDs
# https://doc.traefik.io/traefik/https/tls/#tls-options
# When using `labelSelector`, you'll need to set labels on tlsOption accordingly.
# Example:
# tlsOptions:
#   default:
#     labels: {}
#     sniStrict: true
#     preferServerCipherSuites: true
#   customOptions:
#     labels: {}
#     curvePreferences:
#       - CurveP521
#       - CurveP384
tlsOptions: {}

# -- TLS Store are created as TLSStore CRDs. This is useful if you want to set a default certificate
# https://doc.traefik.io/traefik/https/tls/#default-certificate
# Example:
# tlsStore:
#   default:
#     defaultCertificate:
#       secretName: tls-cert
tlsStore: {}

service:
  enabled: true
  ## -- Single service is using `MixedProtocolLBService` feature gate.
  ## -- When set to false, it will create two Service, one for TCP and one for UDP.
  single: true
  type: LoadBalancer
  # -- Additional annotations applied to both TCP and UDP services (e.g. for cloud provider specific config)
  annotations: {}
  # annotations:
  #   service.beta.kubernetes.io/aws-load-balancer-internal: "true"
  #   service.beta.kubernetes.io/aws-load-balancer-type: nlb
  #   service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp
  #   service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
  #   service.beta.kubernetes.io/aws-load-balancer-scheme: "internal"  # XXX: only available via VPN to internal networks
  annotationsTCP: {}
  annotationsUDP: {}
  labels: {}
  # -- Additional entries here will be added to the service spec.
  # -- Cannot contain type, selector or ports entries.
  spec:
    loadBalancerIP: 192.168.40.180 # this should be an IP in the MetalLB range
    # loadBalancerSourceRanges:
    #     - 192.168.0.0/16
    #     - 172.16.0.0/12
    #     - 10.0.0.0/8
  loadBalancerSourceRanges: []
  # - 192.168.0.1/32
  # - 172.16.0.0/16
  ## -- Class of the load balancer implementation
  # loadBalancerClass: service.k8s.aws/nlb
  externalIPs: []


autoscaling:
  # -- Create HorizontalPodAutoscaler object.
  enabled: false
#   minReplicas: 1
#   maxReplicas: 10
#   metrics:
#   - type: Resource
#     resource:
#       name: cpu
#       target:
#         type: Utilization
#         averageUtilization: 60
#   - type: Resource
#     resource:
#       name: memory
#       target:
#         type: Utilization
#         averageUtilization: 60
#   behavior:
#     scaleDown:
#       stabilizationWindowSeconds: 300
#       policies:
#       - type: Pods
#         value: 1
#         periodSeconds: 60

persistence:
  enabled: true
  name: data
  #  existingClaim: ""
  accessMode: ReadWriteOnce
  size: 128Mi
  storageClass: "local-path"
  volumeName: traefik-logs
  path: /data
  annotations: {}
  # -- Only mount a subpath of the Volume into the pod
  # subPath: ""

# -- Certificates resolvers configuration
certResolvers: {}

hostNetwork: false

# -- Whether Role Based Access Control objects like roles and rolebindings should be created
rbac:
  enabled: true
  namespaced: false

# -- Enable to create a PodSecurityPolicy and assign it to the Service Account via RoleBinding or ClusterRoleBinding
podSecurityPolicy:
  enabled: false

# -- The service account the pods will use to interact with the Kubernetes API
serviceAccount:
  name: ""

serviceAccountAnnotations: {}
resources: {}
affinity: {}
nodeSelector: {}
tolerations: []

topologySpreadConstraints: []


# -- Pods can have priority.
# -- Priority indicates the importance of a Pod relative to other Pods.
priorityClassName: "system-cluster-critical"

securityContext:
  capabilities:
    drop: [ALL]
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false

podSecurityContext:
  fsGroupChangePolicy: "OnRootMismatch"
  runAsGroup: 65532
  runAsNonRoot: true
  runAsUser: 65532

#
# -- Extra objects to deploy (value evaluated as a template)
#
# In some cases, it can avoid the need for additional, extended or adhoc deployments.
# See #595 for more details and traefik/tests/values/extra.yaml for example.
extraObjects: []

# This will override the default Release Namespace for Helm.
# It will not affect optional CRDs such as `ServiceMonitor` and `PrometheusRules`
# namespaceOverride: traefik
#
## -- This will override the default app.kubernetes.io/instance label for all Objects.
# instanceLabelOverride: traefik

prometheus:
  enabled: true
  servicemonitor:
    enabled: true
    prometheusInstance: default
    targetPort: 9100 #9402
    path: /metrics
    interval: 60s
    scrapeTimeout: 30s
    labels: {}
    annotations: {}
    honorLabels: false
    endpointAdditionalProperties: {}
  # Note: Enabling both PodMonitor and ServiceMonitor is mutually exclusive, enabling both will result in a error.
  # podmonitor:
  #   enabled: false
  #   prometheusInstance: default
  #   path: /metrics
  #   interval: 60s
  #   scrapeTimeout: 30s
  #   labels: {}
  #   annotations: {}
  #   honorLabels: false
  #   endpointAdditionalProperties: {}